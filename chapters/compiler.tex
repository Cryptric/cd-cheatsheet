A compiler translates one programming language to another. The simplified compiler has the following structure:
\begin{compactitem}[$\quad\bullet$]
	\item Lexical Analysis: Source Code $\to$ Token Stream
	\item Parsing: Token Stream $\to$ AST
	\item Intermediate Code Generation: AST $\to$ Intermediate Code
	\item Code Generation: Intermediate Code $\to$ Target Code
\end{compactitem}

The first two steps are the frontend and machine independent, the last step is the backend and machine dependent.

\begin{definition}[Compiler Bug ]
  \begin{itemize*}
      \item Miscompilation (wrong code bug)
      \item Internal compilation error (ICE)
      \item Compiler hang (slow compilation)
      \item Missed optimizations
  \end{itemize*}
\end{definition}

\textbf{Compiler Stages}:
  \begin{compactitem}
    \item Lexing $\rightarrow$ token stream
    \item Parsing $\rightarrow$ abstract syntax
    \item Disambiguation $\rightarrow$ abstract syntax
    \item Semantic analysis $\rightarrow$ annotated abstract syntax
    \item Translation $\rightarrow$ intermediate code
    \item Control-flow analysis $\rightarrow$ control-flow graph
    \item Data-flow analysis $\rightarrow$ interference graph
    \item Register allocation $\rightarrow$ assembly
    \item Code emission
    \item \textbf{Optimization} may be done at many of these stages!
  \end{compactitem}
  
